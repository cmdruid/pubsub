
name: Publish a new release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Checkout the repository at the specific tag
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      # Verify we're on the correct commit
      - name: Verify checkout
        run: |
          echo "üîç Verifying checkout..."
          echo "Git ref: ${{ github.ref }}"
          echo "Git SHA: $(git rev-parse HEAD)"
          echo "Git tag: $(git describe --tags --exact-match HEAD 2>/dev/null || echo 'No exact tag match')"
          echo "Current branch: $(git branch --show-current || echo 'Detached HEAD')"
          echo "Commit message: $(git log -1 --pretty=format:'%s')"
          echo "Commit date: $(git log -1 --pretty=format:'%ci')"

      # Set up JDK 21
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
        
      # Verify Java installation and set JAVA_HOME
      - name: Verify Java installation
        run: |
          echo "JAVA_HOME: $JAVA_HOME"
          java -version
          echo "Setting JAVA_HOME for Gradle"
          echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
          echo "org.gradle.java.home=$JAVA_HOME" >> gradle.properties
          echo "Current gradle.properties content:"
          cat gradle.properties
          echo "Environment variables:"
          env | grep -i java || true

      # Setup Android SDK
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      # Cache Gradle packages (with Java 21 fix)
      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-java21-fix-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-java21-fix-
            ${{ runner.os }}-gradle-

      # Grant execute permission for gradlew
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        
      # Clear Gradle daemon and check setup
      - name: Clear Gradle daemon and check setup
        run: |
          echo "Stopping any existing Gradle daemons:"
          ./gradlew --stop || true
          echo "Gradle wrapper version:"
          ./gradlew --version
          echo "Java version being used by Gradle:"
          ./gradlew -q javaToolchains || echo "javaToolchains task not available"

      # Parse git tag and determine version
      - name: Parse tag and set version
        id: get_version
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/v}
          if [[ "$TAG_NAME" == *"-dev"* ]] || [[ "$TAG_NAME" == *"-beta"* ]]; then
            echo "VERSION=${TAG_NAME}" >> $GITHUB_ENV
            echo "IS_PRERELEASE=true" >> $GITHUB_ENV
          else
            echo "VERSION=${TAG_NAME}" >> $GITHUB_ENV
            echo "IS_PRERELEASE=false" >> $GITHUB_ENV
          fi

      # Update version in build.gradle.kts
      - name: Update version in build.gradle.kts
        run: |
          echo "üìù Updating version in build.gradle.kts to: ${{ env.VERSION }}"
          sed -i "s/versionName = \".*\"/versionName = \"${{ env.VERSION }}\"/" app/build.gradle.kts
          echo "‚úÖ Version updated. Current build.gradle.kts version:"
          grep "versionName" app/build.gradle.kts

      # Build release APK
      - name: Build release APK
        run: |
          echo "Building release APK with Java: $JAVA_HOME"
          ./gradlew assembleRelease --stacktrace
        env:
          JAVA_HOME: ${{ env.JAVA_HOME }}
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}

      # Verify APK version
      - name: Verify APK version
        run: |
          echo "üîç Verifying APK version..."
          # Find the APK file
          APK_PATH=$(find app/build/outputs/apk/release -name "pubsub-*-release*.apk" | head -1)
          if [ -z "$APK_PATH" ]; then
            APK_PATH=$(find app/build/outputs/apk/release -name "app-release*.apk" | head -1)
          fi
          
          if [ -f "$APK_PATH" ]; then
            echo "üì¶ APK found: $APK_PATH"
            echo "üìè APK size: $(ls -lh "$APK_PATH" | awk '{print $5}')"
            echo "üìÖ APK modified: $(ls -l "$APK_PATH" | awk '{print $6, $7, $8}')"
            
            # Extract version info from APK (if aapt is available)
            if command -v aapt >/dev/null 2>&1; then
              echo "üìã APK version info:"
              aapt dump badging "$APK_PATH" | grep -E "(package|versionName)" || echo "Could not extract version info"
            else
              echo "‚ÑπÔ∏è  aapt not available for version extraction"
            fi
          else
            echo "‚ùå No APK found to verify"
          fi

      # Extract changelog entry for the version
      - name: Extract changelog
        id: changelog
        run: |
          # Always look for base version in changelog (strip prerelease suffix if present)
          if [[ "${{ env.VERSION }}" == *"-dev"* ]] || [[ "${{ env.VERSION }}" == *"-alpha"* ]] || [[ "${{ env.VERSION }}" == *"-rc"* ]]; then
            BASE_VERSION=$(echo "${{ env.VERSION }}" | sed 's/-dev.*//;s/-alpha.*//;s/-rc.*//')
          else
            BASE_VERSION=${{ env.VERSION }}
          fi
          
          # Check if CHANGELOG.md exists, if not create a simple changelog entry
          if [ ! -f "CHANGELOG.md" ]; then
            echo "CHANGELOG=Release v${{ env.VERSION }}" >> $GITHUB_ENV
          else
            # Use awk with string comparison to avoid regex escaping issues
            CHANGELOG=$(awk -v version="$BASE_VERSION" '
              BEGIN { target = "## [" version "]" }
              $0 == target { found = 1; next }
              found && substr($0, 1, 4) == "## [" { exit }
              found && NF > 0 { print }
            ' CHANGELOG.md)
            if [ -z "$CHANGELOG" ]; then
              echo "CHANGELOG=Release v${{ env.VERSION }}" >> $GITHUB_ENV
            else
              echo "CHANGELOG<<EOF" >> $GITHUB_ENV
              echo "$CHANGELOG" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            fi
          fi

      # Create GitHub release with APK
      - name: Create Release
        run: |
          # Find the actual APK file with our custom naming scheme
          echo "üîç Looking for APK files in release directory..."
          ls -la app/build/outputs/apk/release/ || echo "Release directory not found yet"
          
          # Look for any APK with pubsub naming (signed or unsigned)
          APK_PATH=$(find app/build/outputs/apk/release -name "pubsub-*-release*.apk" | head -1)
          
          if [ -n "$APK_PATH" ]; then
            echo "‚úÖ Found custom-named APK: $APK_PATH"
          else
            echo "‚ö†Ô∏è  Custom-named APK not found, trying fallback naming..."
            # Try signed first, then unsigned
            if [ -f "app/build/outputs/apk/release/app-release.apk" ]; then
              APK_PATH="app/build/outputs/apk/release/app-release.apk"
              echo "üì¶ Using fallback signed APK: $APK_PATH"
            elif [ -f "app/build/outputs/apk/release/app-release-unsigned.apk" ]; then
              APK_PATH="app/build/outputs/apk/release/app-release-unsigned.apk"
              echo "üì¶ Using fallback unsigned APK: $APK_PATH"
            else
              echo "‚ùå No APK found with any naming scheme"
            fi
          fi
          
          # Determine if APK is signed based on filename
          if [[ "$APK_PATH" == *"unsigned"* ]]; then
            echo "‚ÑπÔ∏è  Note: Using unsigned APK (signing secrets not available or signing failed)"
          else
            echo "‚úÖ Using signed APK"
          fi
          
          # Verify APK exists and show info
          if [ ! -f "$APK_PATH" ]; then
            echo "‚ùå APK not found at: $APK_PATH"
            echo "Available files in release directory:"
            ls -la app/build/outputs/apk/release/ || echo "Release directory not found"
            exit 1
          fi
          
          echo "‚úÖ APK found: $APK_PATH"
          echo "APK size: $(ls -lh "$APK_PATH" | awk '{print $5}')"
          
          # Check if release already exists and delete it
          if gh release view "v${{ env.VERSION }}" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Release v${{ env.VERSION }} already exists. Deleting..."
            gh release delete "v${{ env.VERSION }}" --yes || true
            echo "‚úÖ Existing release deleted"
          fi
          
          # Create new release
          if [ "${{ env.IS_PRERELEASE }}" = "true" ]; then
            gh release create "v${{ env.VERSION }}" \
              --title "Release v${{ env.VERSION }}" \
              --notes "${{ env.CHANGELOG }}" \
              --prerelease \
              "$APK_PATH"
          else
            gh release create "v${{ env.VERSION }}" \
              --title "Release v${{ env.VERSION }}" \
              --notes "${{ env.CHANGELOG }}" \
              "$APK_PATH"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

